local players = cloneref(game:GetService("Players"))
local client = players.LocalPlayer
local camera = workspace.CurrentCamera
local RunService = cloneref(game:GetService("RunService"))

getgenv().global = getgenv()

function global.declare(self, index, value, check)
    if self[index] == nil then
        self[index] = value
    elseif check then
        local methods = { "remove", "Disconnect" }
        for _, method in methods do
            pcall(function() value[method](value) end)
        end
    end
    return self[index]
end

declare(global, "services", {})
declare(declare(services, "loop", {}), "cache", {})
declare(declare(services, "player", {}), "cache", {})
declare(declare(services, "new", {}), "drawingPool", {
    Square = {}, Line = {}, Text = {}
})

function global.get(service)
    return services[service]
end

get("loop").new = function(self, index, func, disabled)
    if disabled == nil and (func == nil or typeof(func) == "boolean") then
        disabled = func func = index
    end
    self.cache[index] = {
        ["enabled"] = (not disabled),
        ["func"] = func,
        ["toggle"] = function(self, boolean)
            self.enabled = boolean ~= nil and boolean or not self.enabled
        end,
        ["remove"] = function()
            self.cache[index] = nil
        end
    }
    return self.cache[index]
end

declare(get("loop"), "connection", RunService.RenderStepped:Connect(function(delta)
    if math.floor(os.clock() * 100) % 3 ~= 0 then return end
    for _, loop in get("loop").cache do
        if loop.enabled then
            pcall(loop.func, delta)
        end
    end
end), true)

get("new").drawing = function(class, properties)
    local pool = get("new").drawingPool[class]
    local drawing = #pool > 0 and table.remove(pool) or Drawing.new(class)
    for property, value in properties do
        pcall(function() drawing[property] = value end)
    end
    return drawing
end

get("player").find = function(self, player)
    for character, data in self.cache do
        if data.player == player then
            return character
        end
    end
end

get("player").check = function(self, player)
    local success = pcall(function()
        local character = player:IsA("Player") and player.Character or player
        return character.Humanoid and character.HumanoidRootPart and character.Parent
    end)
    return success
end

get("player").new = function(self, player)
    local function cache(character)
        self.cache[character] = {
            ["player"] = player,
            ["drawings"] = {
                ["box"] = get("new").drawing("Square", { Visible = false }),
                ["boxFilled"] = get("new").drawing("Square", { Visible = false, Filled = true }),
                ["boxOutline"] = get("new").drawing("Square", { Visible = false }),
                ["name"] = get("new").drawing("Text", { Visible = false, Center = true}),
                ["health"] = get("new").drawing("Line", { Visible = false }),
                ["healthOutline"] = get("new").drawing("Line", { Visible = false }),
                ["healthText"] = get("new").drawing("Text", { Visible = false, Center = false}),
                ["distance"] = get("new").drawing("Text", { Visible = false, Center = true}),
                ["weapon"] = get("new").drawing("Text", { Visible = false, Center = true}),
                ["tracer"] = get("new").drawing("Line", { Visible = false }),
                ["tracerOutline"] = get("new").drawing("Line", { Visible = false }),
                ["cornerTLH"] = get("new").drawing("Line", { Visible = false }),
                ["cornerTLV"] = get("new").drawing("Line", { Visible = false }),
                ["cornerTRH"] = get("new").drawing("Line", { Visible = false }),
                ["cornerTRV"] = get("new").drawing("Line", { Visible = false }),
                ["cornerBLH"] = get("new").drawing("Line", { Visible = false }),
                ["cornerBLV"] = get("new").drawing("Line", { Visible = false }),
                ["cornerBRH"] = get("new").drawing("Line", { Visible = false }),
                ["cornerBRV"] = get("new").drawing("Line", { Visible = false }),
                ["cornerTLHOutline"] = get("new").drawing("Line", { Visible = false }),
                ["cornerTLVOutline"] = get("new").drawing("Line", { Visible = false }),
                ["cornerTRHOutline"] = get("new").drawing("Line", { Visible = false }),
                ["cornerTRVOutline"] = get("new").drawing("Line", { Visible = false }),
                ["cornerBLHOutline"] = get("new").drawing("Line", { Visible = false }),
                ["cornerBLVOutline"] = get("new").drawing("Line", { Visible = false }),
                ["cornerBRHOutline"] = get("new").drawing("Line", { Visible = false }),
                ["cornerBRVOutline"] = get("new").drawing("Line", { Visible = false }),
                ["cornerFilledTL"] = get("new").drawing("Square", { Visible = false, Filled = true }),
                ["cornerFilledTR"] = get("new").drawing("Square", { Visible = false, Filled = true }),
                ["cornerFilledBL"] = get("new").drawing("Square", { Visible = false, Filled = true }),
                ["cornerFilledBR"] = get("new").drawing("Square", { Visible = false, Filled = true }),
            }
        }
    end

    local function check(character)
        if self:check(character) then
            cache(character)
        else
            local listener
            listener = character.ChildAdded:Connect(function()
                if self:check(character) then
                    cache(character)
                    listener:Disconnect()
                end
            end)
        end
    end

    if player.Character then check(player.Character) end
    player.CharacterAdded:Connect(check)
end

get("player").remove = function(self, player)
    local data = self.cache[player]
    if not data then return end
    local pool = get("new").drawingPool
    for name, drawing in pairs(data.drawings) do
        drawing.Visible = false
        table.insert(pool[drawing.ClassName], drawing)
    end
    self.cache[player] = nil
end

get("player").update = function(self, character, data)
    if not self:check(character) then return self:remove(character) end
    local player = data.player
    if player == client then return end

    local root = character.HumanoidRootPart
    local humanoid = character.Humanoid
    local drawings = data.drawings
    local visuals = features.visuals

    if self:check(client) then
        data.distance = (client.Character.HumanoidRootPart.Position - root.Position).Magnitude
        if data.distance > visuals.renderDistance then
            for _, drawing in pairs(drawings) do drawing.Visible = false end
            return
        end
    end

    local position, visible = camera:WorldToViewportPoint(root.Position)
    if not visible then return end

    local scale = 1 / (position.Z * math.tan(math.rad(camera.FieldOfView * 0.5)) * 2) * 1000
    local width, height = math.floor(4.5 * scale), math.floor(6 * scale)
    local x, y = math.floor(position.X), math.floor(position.Y)
    local xPosition, yPosition = math.floor(x - width * 0.5), math.floor((y - height * 0.5) + (0.5 * scale))

    local teamCheck = visuals.teamCheck and player.Team ~= client.Team or true
    if not (visuals.enabled and teamCheck) then return end

    local tracerStart = visuals.tracer.startPosition == "bottom" and Vector2.new(camera.ViewportSize.X/2, camera.ViewportSize.Y)
        or visuals.tracer.startPosition == "center" and Vector2.new(camera.ViewportSize.X/2, camera.ViewportSize.Y/2)
        or Vector2.new(camera.ViewportSize.X/2, camera.ViewportSize.Y)

    local boxVisible = visuals.boxes.enabled and visuals.boxes.style == "Box"
    local cornerVisible = visuals.boxes.enabled and visuals.boxes.style == "Corners"

    drawings.box.Visible = boxVisible
    drawings.boxFilled.Visible = boxVisible and visuals.boxes.filled.enabled
    drawings.boxOutline.Visible = boxVisible and visuals.boxes.outline.enabled

    if boxVisible then
        drawings.box.Size = Vector2.new(width, height)
        drawings.box.Position = Vector2.new(xPosition, yPosition)
        drawings.box.Color = visuals.teamColor and player.TeamColor.Color or visuals.boxes.color
    end

    if cornerVisible then
        for _, corner in pairs({"cornerTLH", "cornerTLV", "cornerTRH", "cornerTRV", "cornerBLH", "cornerBLV", "cornerBRH", "cornerBRV"}) do
            drawings[corner].Visible = true
        end
    end

    if visuals.tracer.enabled then
        drawings.tracer.From = tracerStart
        drawings.tracer.To = Vector2.new(x, y)
        drawings.tracer.Color = visuals.teamColor and player.TeamColor.Color or visuals.tracer.color
        drawings.tracerOutline.From = tracerStart
        drawings.tracerOutline.To = Vector2.new(x, y)
    end

    if visuals.names.enabled then
        drawings.name.Text = player.Name
        drawings.name.Position = Vector2.new(x, yPosition - 20)
        drawings.name.Color = visuals.teamColor and player.TeamColor.Color or visuals.names.color
    end

    if visuals.health.enabled then
        local healthPercent = humanoid.Health / humanoid.MaxHealth
        drawings.health.From = Vector2.new(xPosition - 5, yPosition + height)
        drawings.health.To = Vector2.new(xPosition - 5, yPosition + height * (1 - healthPercent))
        drawings.health.Color = visuals.health.color:Lerp(visuals.health.colorLow, 1 - healthPercent)
    end
end

declare(get("player"), "loop", get("loop"):new(function()
    for character, data in get("player").cache do
        get("player"):update(character, data)
    end
end), true)

declare(global, "features", {
    visuals = {
        enabled = false,
        teamCheck = false,
        teamColor = true,
        renderDistance = 2000,
        boxes = { enabled = true, style = "Box", color = Color3.new(1,1,1), 
            outline = { enabled = true, color = Color3.new() }, 
            filled = { enabled = true, color = Color3.new(1,1,1), transparency = 0.25 } },
        names = { enabled = true, color = Color3.new(1,1,1), 
            outline = { enabled = true, color = Color3.new() } },
        health = { enabled = true, color = Color3.new(0,1,0), colorLow = Color3.new(1,0,0), 
            outline = { enabled = true, color = Color3.new() }, text = { enabled = true } },
        distance = { enabled = true, color = Color3.new(1,1,1), 
            outline = { enabled = true, color = Color3.new() } },
        weapon = { enabled = true, color = Color3.new(1,1,1), 
            outline = { enabled = true, color = Color3.new() } },
        tracer = { enabled = false, startPosition = "bottom", 
            color = Color3.new(1,1,1), outline = { enabled = true, color = Color3.new() } }
    }
})

for _, player in players:GetPlayers() do
    if player ~= client then
        get("player"):new(player)
    end
end

declare(get("player"), "added", players.PlayerAdded:Connect(function(player)
    get("player"):new(player)
end), true)

declare(get("player"), "removing", players.PlayerRemoving:Connect(function(player)
    get("player"):remove(player)
end), true)
